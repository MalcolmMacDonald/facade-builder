{"mappings":"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","sources":["<anon>","src/decomp.js"],"sourcesContent":["!function(e) {\n    if (\"object\" == typeof exports && \"undefined\" != typeof module) module.exports = e();\n    else if (\"function\" == typeof define && define.amd) define([], e);\n    else {\n        var f;\n        \"undefined\" != typeof window ? f = window : \"undefined\" != typeof global ? f = global : \"undefined\" != typeof self && (f = self), f.decomp = e();\n    }\n}(function() {\n    var define1, module1, exports1;\n    return (function e(t, n, r) {\n        function s(o, u) {\n            if (!n[o]) {\n                if (!t[o]) {\n                    var a = typeof require == \"function\" && undefined;\n                    if (!u && a) return a(o, !0);\n                    if (i) return i(o, !0);\n                    throw new Error(\"Cannot find module '\" + o + \"'\");\n                }\n                var f = n[o] = {\n                    exports: {}\n                };\n                t[o][0].call(f.exports, function(e) {\n                    var n = t[o][1][e];\n                    return s(n ? n : e);\n                }, f, f.exports, e, t, n, r);\n            }\n            return n[o].exports;\n        }\n        var i = typeof require == \"function\" && undefined;\n        for(var o = 0; o < r.length; o++)s(r[o]);\n        return s;\n    })({\n        1: [\n            function(_dereq_, module1, exports1) {\n                module1.exports = {\n                    decomp: polygonDecomp,\n                    quickDecomp: polygonQuickDecomp,\n                    isSimple: polygonIsSimple,\n                    removeCollinearPoints: polygonRemoveCollinearPoints,\n                    removeDuplicatePoints: polygonRemoveDuplicatePoints,\n                    makeCCW: polygonMakeCCW\n                };\n                /**\n * Compute the intersection between two lines.\n * @static\n * @method lineInt\n * @param  {Array}  l1          Line vector 1\n * @param  {Array}  l2          Line vector 2\n * @param  {Number} precision   Precision to use when checking if the lines are parallel\n * @return {Array}              The intersection point.\n */ function lineInt(l1, l2, precision) {\n                    precision = precision || 0;\n                    var i = [\n                        0,\n                        0\n                    ]; // point\n                    var a1, b1, c1, a2, b2, c2, det; // scalars\n                    a1 = l1[1][1] - l1[0][1];\n                    b1 = l1[0][0] - l1[1][0];\n                    c1 = a1 * l1[0][0] + b1 * l1[0][1];\n                    a2 = l2[1][1] - l2[0][1];\n                    b2 = l2[0][0] - l2[1][0];\n                    c2 = a2 * l2[0][0] + b2 * l2[0][1];\n                    det = a1 * b2 - a2 * b1;\n                    if (!scalar_eq(det, 0, precision)) {\n                        i[0] = (b2 * c1 - b1 * c2) / det;\n                        i[1] = (a1 * c2 - a2 * c1) / det;\n                    }\n                    return i;\n                }\n                /**\n * Checks if two line segments intersects.\n * @method segmentsIntersect\n * @param {Array} p1 The start vertex of the first line segment.\n * @param {Array} p2 The end vertex of the first line segment.\n * @param {Array} q1 The start vertex of the second line segment.\n * @param {Array} q2 The end vertex of the second line segment.\n * @return {Boolean} True if the two line segments intersect\n */ function lineSegmentsIntersect(p1, p2, q1, q2) {\n                    var dx = p2[0] - p1[0];\n                    var dy = p2[1] - p1[1];\n                    var da = q2[0] - q1[0];\n                    var db = q2[1] - q1[1];\n                    // segments are parallel\n                    if (da * dy - db * dx === 0) return false;\n                    var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);\n                    var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);\n                    return s >= 0 && s <= 1 && t >= 0 && t <= 1;\n                }\n                /**\n * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.\n * @static\n * @method area\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @return {Number}\n */ function triangleArea(a, b, c) {\n                    return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);\n                }\n                function isLeft(a, b, c) {\n                    return triangleArea(a, b, c) > 0;\n                }\n                function isLeftOn(a, b, c) {\n                    return triangleArea(a, b, c) >= 0;\n                }\n                function isRight(a, b, c) {\n                    return triangleArea(a, b, c) < 0;\n                }\n                function isRightOn(a, b, c) {\n                    return triangleArea(a, b, c) <= 0;\n                }\n                var tmpPoint1 = [], tmpPoint2 = [];\n                /**\n * Check if three points are collinear\n * @method collinear\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.\n * @return {Boolean}\n */ function collinear(a, b, c, thresholdAngle) {\n                    if (!thresholdAngle) return triangleArea(a, b, c) === 0;\n                    else {\n                        var ab = tmpPoint1, bc = tmpPoint2;\n                        ab[0] = b[0] - a[0];\n                        ab[1] = b[1] - a[1];\n                        bc[0] = c[0] - b[0];\n                        bc[1] = c[1] - b[1];\n                        var dot = ab[0] * bc[0] + ab[1] * bc[1], magA = Math.sqrt(ab[0] * ab[0] + ab[1] * ab[1]), magB = Math.sqrt(bc[0] * bc[0] + bc[1] * bc[1]), angle = Math.acos(dot / (magA * magB));\n                        return angle < thresholdAngle;\n                    }\n                }\n                function sqdist(a, b) {\n                    var dx = b[0] - a[0];\n                    var dy = b[1] - a[1];\n                    return dx * dx + dy * dy;\n                }\n                /**\n * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.\n * @method at\n * @param  {Number} i\n * @return {Array}\n */ function polygonAt(polygon, i) {\n                    var s = polygon.length;\n                    return polygon[i < 0 ? i % s + s : i % s];\n                }\n                /**\n * Clear the polygon data\n * @method clear\n * @return {Array}\n */ function polygonClear(polygon) {\n                    polygon.length = 0;\n                }\n                /**\n * Append points \"from\" to \"to\"-1 from an other polygon \"poly\" onto this one.\n * @method append\n * @param {Polygon} poly The polygon to get points from.\n * @param {Number}  from The vertex index in \"poly\".\n * @param {Number}  to The end vertex index in \"poly\". Note that this vertex is NOT included when appending.\n * @return {Array}\n */ function polygonAppend(polygon, poly, from, to) {\n                    for(var i = from; i < to; i++)polygon.push(poly[i]);\n                }\n                /**\n * Make sure that the polygon vertices are ordered counter-clockwise.\n * @method makeCCW\n */ function polygonMakeCCW(polygon) {\n                    var br = 0, v = polygon;\n                    // find bottom right point\n                    for(var i = 1; i < polygon.length; ++i)if (v[i][1] < v[br][1] || v[i][1] === v[br][1] && v[i][0] > v[br][0]) br = i;\n                    // reverse poly if clockwise\n                    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {\n                        polygonReverse(polygon);\n                        return true;\n                    } else return false;\n                }\n                /**\n * Reverse the vertices in the polygon\n * @method reverse\n */ function polygonReverse(polygon) {\n                    var tmp = [];\n                    var N = polygon.length;\n                    for(var i = 0; i !== N; i++)tmp.push(polygon.pop());\n                    for(var i = 0; i !== N; i++)polygon[i] = tmp[i];\n                }\n                /**\n * Check if a point in the polygon is a reflex point\n * @method isReflex\n * @param  {Number}  i\n * @return {Boolean}\n */ function polygonIsReflex(polygon, i) {\n                    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));\n                }\n                var tmpLine1 = [], tmpLine2 = [];\n                /**\n * Check if two vertices in the polygon can see each other\n * @method canSee\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */ function polygonCanSee(polygon, a, b) {\n                    var p, dist, l1 = tmpLine1, l2 = tmpLine2;\n                    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) return false;\n                    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));\n                    for(var i = 0; i !== polygon.length; ++i){\n                        if ((i + 1) % polygon.length === a || i === a) continue;\n                        if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) {\n                            l1[0] = polygonAt(polygon, a);\n                            l1[1] = polygonAt(polygon, b);\n                            l2[0] = polygonAt(polygon, i);\n                            l2[1] = polygonAt(polygon, i + 1);\n                            p = lineInt(l1, l2);\n                            if (sqdist(polygonAt(polygon, a), p) < dist) return false;\n                        }\n                    }\n                    return true;\n                }\n                /**\n * Check if two vertices in the polygon can see each other\n * @method canSee2\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */ function polygonCanSee2(polygon, a, b) {\n                    // for each edge\n                    for(var i = 0; i !== polygon.length; ++i){\n                        // ignore incident edges\n                        if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b) continue;\n                        if (lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i + 1))) return false;\n                    }\n                    return true;\n                }\n                /**\n * Copy the polygon from vertex i to vertex j.\n * @method copy\n * @param  {Number} i\n * @param  {Number} j\n * @param  {Polygon} [targetPoly]   Optional target polygon to save in.\n * @return {Polygon}                The resulting copy.\n */ function polygonCopy(polygon, i, j, targetPoly) {\n                    var p = targetPoly || [];\n                    polygonClear(p);\n                    if (i < j) // Insert all vertices from i to j\n                    for(var k = i; k <= j; k++)p.push(polygon[k]);\n                    else {\n                        // Insert vertices 0 to j\n                        for(var k = 0; k <= j; k++)p.push(polygon[k]);\n                        // Insert vertices i to end\n                        for(var k = i; k < polygon.length; k++)p.push(polygon[k]);\n                    }\n                    return p;\n                }\n                /**\n * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.\n * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.\n * @method getCutEdges\n * @return {Array}\n */ function polygonGetCutEdges(polygon) {\n                    var min = [], tmp1 = [], tmp2 = [], tmpPoly = [];\n                    var nDiags = Number.MAX_VALUE;\n                    for(var i = 0; i < polygon.length; ++i)if (polygonIsReflex(polygon, i)) {\n                        for(var j = 0; j < polygon.length; ++j)if (polygonCanSee(polygon, i, j)) {\n                            tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));\n                            tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));\n                            for(var k = 0; k < tmp2.length; k++)tmp1.push(tmp2[k]);\n                            if (tmp1.length < nDiags) {\n                                min = tmp1;\n                                nDiags = tmp1.length;\n                                min.push([\n                                    polygonAt(polygon, i),\n                                    polygonAt(polygon, j)\n                                ]);\n                            }\n                        }\n                    }\n                    return min;\n                }\n                /**\n * Decomposes the polygon into one or more convex sub-Polygons.\n * @method decomp\n * @return {Array} An array or Polygon objects.\n */ function polygonDecomp(polygon) {\n                    var edges = polygonGetCutEdges(polygon);\n                    if (edges.length > 0) return polygonSlice(polygon, edges);\n                    else return [\n                        polygon\n                    ];\n                }\n                /**\n * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.\n * @method slice\n * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()\n * @return {Array}\n */ function polygonSlice(polygon, cutEdges) {\n                    if (cutEdges.length === 0) return [\n                        polygon\n                    ];\n                    if (cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length === 2 && cutEdges[0][0] instanceof Array) {\n                        var polys = [\n                            polygon\n                        ];\n                        for(var i = 0; i < cutEdges.length; i++){\n                            var cutEdge = cutEdges[i];\n                            // Cut all polys\n                            for(var j = 0; j < polys.length; j++){\n                                var poly = polys[j];\n                                var result = polygonSlice(poly, cutEdge);\n                                if (result) {\n                                    // Found poly! Cut and quit\n                                    polys.splice(j, 1);\n                                    polys.push(result[0], result[1]);\n                                    break;\n                                }\n                            }\n                        }\n                        return polys;\n                    } else {\n                        // Was given one edge\n                        var cutEdge = cutEdges;\n                        var i = polygon.indexOf(cutEdge[0]);\n                        var j = polygon.indexOf(cutEdge[1]);\n                        if (i !== -1 && j !== -1) return [\n                            polygonCopy(polygon, i, j),\n                            polygonCopy(polygon, j, i)\n                        ];\n                        else return false;\n                    }\n                }\n                /**\n * Checks that the line segments of this polygon do not intersect each other.\n * @method isSimple\n * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]\n * @return {Boolean}\n * @todo Should it check all segments with all others?\n */ function polygonIsSimple(polygon) {\n                    var path = polygon, i;\n                    // Check\n                    for(i = 0; i < path.length - 1; i++)for(var j = 0; j < i - 1; j++){\n                        if (lineSegmentsIntersect(path[i], path[i + 1], path[j], path[j + 1])) return false;\n                    }\n                    // Check the segment between the last and the first point to all others\n                    for(i = 1; i < path.length - 2; i++){\n                        if (lineSegmentsIntersect(path[0], path[path.length - 1], path[i], path[i + 1])) return false;\n                    }\n                    return true;\n                }\n                function getIntersectionPoint(p1, p2, q1, q2, delta) {\n                    delta = delta || 0;\n                    var a1 = p2[1] - p1[1];\n                    var b1 = p1[0] - p2[0];\n                    var c1 = a1 * p1[0] + b1 * p1[1];\n                    var a2 = q2[1] - q1[1];\n                    var b2 = q1[0] - q2[0];\n                    var c2 = a2 * q1[0] + b2 * q1[1];\n                    var det = a1 * b2 - a2 * b1;\n                    if (!scalar_eq(det, 0, delta)) return [\n                        (b2 * c1 - b1 * c2) / det,\n                        (a1 * c2 - a2 * c1) / det\n                    ];\n                    else return [\n                        0,\n                        0\n                    ];\n                }\n                /**\n * Quickly decompose the Polygon into convex sub-polygons.\n * @method quickDecomp\n * @param  {Array} result\n * @param  {Array} [reflexVertices]\n * @param  {Array} [steinerPoints]\n * @param  {Number} [delta]\n * @param  {Number} [maxlevel]\n * @param  {Number} [level]\n * @return {Array}\n */ function polygonQuickDecomp(polygon, result, reflexVertices, steinerPoints, delta, maxlevel, level) {\n                    maxlevel = maxlevel || 100;\n                    level = level || 0;\n                    delta = delta || 25;\n                    result = typeof result !== \"undefined\" ? result : [];\n                    reflexVertices = reflexVertices || [];\n                    steinerPoints = steinerPoints || [];\n                    var upperInt = [\n                        0,\n                        0\n                    ], lowerInt = [\n                        0,\n                        0\n                    ], p = [\n                        0,\n                        0\n                    ]; // Points\n                    var upperDist = 0, lowerDist = 0, d = 0, closestDist = 0; // scalars\n                    var upperIndex = 0, lowerIndex = 0, closestIndex = 0; // Integers\n                    var lowerPoly = [], upperPoly = []; // polygons\n                    var poly = polygon, v = polygon;\n                    if (v.length < 3) return result;\n                    level++;\n                    if (level > maxlevel) {\n                        console.warn(\"quickDecomp: max level (\" + maxlevel + \") reached.\");\n                        return result;\n                    }\n                    for(var i = 0; i < polygon.length; ++i)if (polygonIsReflex(poly, i)) {\n                        reflexVertices.push(poly[i]);\n                        upperDist = lowerDist = Number.MAX_VALUE;\n                        for(var j = 0; j < polygon.length; ++j){\n                            if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) {\n                                p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection\n                                if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) {\n                                    d = sqdist(poly[i], p);\n                                    if (d < lowerDist) {\n                                        lowerDist = d;\n                                        lowerInt = p;\n                                        lowerIndex = j;\n                                    }\n                                }\n                            }\n                            if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n                                p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));\n                                if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {\n                                    d = sqdist(poly[i], p);\n                                    if (d < upperDist) {\n                                        upperDist = d;\n                                        upperInt = p;\n                                        upperIndex = j;\n                                    }\n                                }\n                            }\n                        }\n                        // if there are no vertices to connect to, choose a point in the middle\n                        if (lowerIndex === (upperIndex + 1) % polygon.length) {\n                            //console.log(\"Case 1: Vertex(\"+i+\"), lowerIndex(\"+lowerIndex+\"), upperIndex(\"+upperIndex+\"), poly.size(\"+polygon.length+\")\");\n                            p[0] = (lowerInt[0] + upperInt[0]) / 2;\n                            p[1] = (lowerInt[1] + upperInt[1]) / 2;\n                            steinerPoints.push(p);\n                            if (i < upperIndex) {\n                                //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);\n                                polygonAppend(lowerPoly, poly, i, upperIndex + 1);\n                                lowerPoly.push(p);\n                                upperPoly.push(p);\n                                if (lowerIndex !== 0) //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());\n                                polygonAppend(upperPoly, poly, lowerIndex, poly.length);\n                                //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);\n                                polygonAppend(upperPoly, poly, 0, i + 1);\n                            } else {\n                                if (i !== 0) //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());\n                                polygonAppend(lowerPoly, poly, i, poly.length);\n                                //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);\n                                polygonAppend(lowerPoly, poly, 0, upperIndex + 1);\n                                lowerPoly.push(p);\n                                upperPoly.push(p);\n                                //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);\n                                polygonAppend(upperPoly, poly, lowerIndex, i + 1);\n                            }\n                        } else {\n                            // connect to the closest point within the triangle\n                            //console.log(\"Case 2: Vertex(\"+i+\"), closestIndex(\"+closestIndex+\"), poly.size(\"+polygon.length+\")\\n\");\n                            if (lowerIndex > upperIndex) upperIndex += polygon.length;\n                            closestDist = Number.MAX_VALUE;\n                            if (upperIndex < lowerIndex) return result;\n                            for(var j = lowerIndex; j <= upperIndex; ++j)if (isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n                                d = sqdist(polygonAt(poly, i), polygonAt(poly, j));\n                                if (d < closestDist && polygonCanSee2(poly, i, j)) {\n                                    closestDist = d;\n                                    closestIndex = j % polygon.length;\n                                }\n                            }\n                            if (i < closestIndex) {\n                                polygonAppend(lowerPoly, poly, i, closestIndex + 1);\n                                if (closestIndex !== 0) polygonAppend(upperPoly, poly, closestIndex, v.length);\n                                polygonAppend(upperPoly, poly, 0, i + 1);\n                            } else {\n                                if (i !== 0) polygonAppend(lowerPoly, poly, i, v.length);\n                                polygonAppend(lowerPoly, poly, 0, closestIndex + 1);\n                                polygonAppend(upperPoly, poly, closestIndex, i + 1);\n                            }\n                        }\n                        // solve smallest poly first\n                        if (lowerPoly.length < upperPoly.length) {\n                            polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n                            polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n                        } else {\n                            polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n                            polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n                        }\n                        return result;\n                    }\n                    result.push(polygon);\n                    return result;\n                }\n                /**\n * Remove collinear points in the polygon.\n * @method removeCollinearPoints\n * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.\n * @return {Number}           The number of points removed\n */ function polygonRemoveCollinearPoints(polygon, precision) {\n                    var num = 0;\n                    for(var i = polygon.length - 1; polygon.length > 3 && i >= 0; --i)if (collinear(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1), precision)) {\n                        // Remove the middle point\n                        polygon.splice(i % polygon.length, 1);\n                        num++;\n                    }\n                    return num;\n                }\n                /**\n * Remove duplicate points in the polygon.\n * @method removeDuplicatePoints\n * @param  {Number} [precision] The threshold to use when determining whether two points are the same. Use zero for best precision.\n */ function polygonRemoveDuplicatePoints(polygon, precision) {\n                    for(var i = polygon.length - 1; i >= 1; --i){\n                        var pi = polygon[i];\n                        for(var j = i - 1; j >= 0; --j)if (points_eq(pi, polygon[j], precision)) {\n                            polygon.splice(i, 1);\n                            continue;\n                        }\n                    }\n                }\n                /**\n * Check if two scalars are equal\n * @static\n * @method eq\n * @param  {Number} a\n * @param  {Number} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */ function scalar_eq(a, b, precision) {\n                    precision = precision || 0;\n                    return Math.abs(a - b) <= precision;\n                }\n                /**\n * Check if two points are equal\n * @static\n * @method points_eq\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */ function points_eq(a, b, precision) {\n                    return scalar_eq(a[0], b[0], precision) && scalar_eq(a[1], b[1], precision);\n                }\n            },\n            {}\n        ]\n    }, {}, [\n        1\n    ])(1);\n});\n\n//# sourceMappingURL=index.75306185.js.map\n","!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.decomp=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\nmodule.exports = {\n    decomp: polygonDecomp,\n    quickDecomp: polygonQuickDecomp,\n    isSimple: polygonIsSimple,\n    removeCollinearPoints: polygonRemoveCollinearPoints,\n    removeDuplicatePoints: polygonRemoveDuplicatePoints,\n    makeCCW: polygonMakeCCW\n};\n\n/**\n * Compute the intersection between two lines.\n * @static\n * @method lineInt\n * @param  {Array}  l1          Line vector 1\n * @param  {Array}  l2          Line vector 2\n * @param  {Number} precision   Precision to use when checking if the lines are parallel\n * @return {Array}              The intersection point.\n */\nfunction lineInt(l1,l2,precision){\n    precision = precision || 0;\n    var i = [0,0]; // point\n    var a1, b1, c1, a2, b2, c2, det; // scalars\n    a1 = l1[1][1] - l1[0][1];\n    b1 = l1[0][0] - l1[1][0];\n    c1 = a1 * l1[0][0] + b1 * l1[0][1];\n    a2 = l2[1][1] - l2[0][1];\n    b2 = l2[0][0] - l2[1][0];\n    c2 = a2 * l2[0][0] + b2 * l2[0][1];\n    det = a1 * b2 - a2*b1;\n    if (!scalar_eq(det, 0, precision)) { // lines are not parallel\n        i[0] = (b2 * c1 - b1 * c2) / det;\n        i[1] = (a1 * c2 - a2 * c1) / det;\n    }\n    return i;\n}\n\n/**\n * Checks if two line segments intersects.\n * @method segmentsIntersect\n * @param {Array} p1 The start vertex of the first line segment.\n * @param {Array} p2 The end vertex of the first line segment.\n * @param {Array} q1 The start vertex of the second line segment.\n * @param {Array} q2 The end vertex of the second line segment.\n * @return {Boolean} True if the two line segments intersect\n */\nfunction lineSegmentsIntersect(p1, p2, q1, q2){\n\tvar dx = p2[0] - p1[0];\n\tvar dy = p2[1] - p1[1];\n\tvar da = q2[0] - q1[0];\n\tvar db = q2[1] - q1[1];\n\n\t// segments are parallel\n\tif((da*dy - db*dx) === 0){\n\t\treturn false;\n\t}\n\n\tvar s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);\n\tvar t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);\n\n\treturn (s>=0 && s<=1 && t>=0 && t<=1);\n}\n\n/**\n * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.\n * @static\n * @method area\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @return {Number}\n */\nfunction triangleArea(a,b,c){\n    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));\n}\n\nfunction isLeft(a,b,c){\n    return triangleArea(a,b,c) > 0;\n}\n\nfunction isLeftOn(a,b,c) {\n    return triangleArea(a, b, c) >= 0;\n}\n\nfunction isRight(a,b,c) {\n    return triangleArea(a, b, c) < 0;\n}\n\nfunction isRightOn(a,b,c) {\n    return triangleArea(a, b, c) <= 0;\n}\n\nvar tmpPoint1 = [],\n    tmpPoint2 = [];\n\n/**\n * Check if three points are collinear\n * @method collinear\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.\n * @return {Boolean}\n */\nfunction collinear(a,b,c,thresholdAngle) {\n    if(!thresholdAngle){\n        return triangleArea(a, b, c) === 0;\n    } else {\n        var ab = tmpPoint1,\n            bc = tmpPoint2;\n\n        ab[0] = b[0]-a[0];\n        ab[1] = b[1]-a[1];\n        bc[0] = c[0]-b[0];\n        bc[1] = c[1]-b[1];\n\n        var dot = ab[0]*bc[0] + ab[1]*bc[1],\n            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),\n            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),\n            angle = Math.acos(dot/(magA*magB));\n        return angle < thresholdAngle;\n    }\n}\n\nfunction sqdist(a,b){\n    var dx = b[0] - a[0];\n    var dy = b[1] - a[1];\n    return dx * dx + dy * dy;\n}\n\n/**\n * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.\n * @method at\n * @param  {Number} i\n * @return {Array}\n */\nfunction polygonAt(polygon, i){\n    var s = polygon.length;\n    return polygon[i < 0 ? i % s + s : i % s];\n}\n\n/**\n * Clear the polygon data\n * @method clear\n * @return {Array}\n */\nfunction polygonClear(polygon){\n    polygon.length = 0;\n}\n\n/**\n * Append points \"from\" to \"to\"-1 from an other polygon \"poly\" onto this one.\n * @method append\n * @param {Polygon} poly The polygon to get points from.\n * @param {Number}  from The vertex index in \"poly\".\n * @param {Number}  to The end vertex index in \"poly\". Note that this vertex is NOT included when appending.\n * @return {Array}\n */\nfunction polygonAppend(polygon, poly, from, to){\n    for(var i=from; i<to; i++){\n        polygon.push(poly[i]);\n    }\n}\n\n/**\n * Make sure that the polygon vertices are ordered counter-clockwise.\n * @method makeCCW\n */\nfunction polygonMakeCCW(polygon){\n    var br = 0,\n        v = polygon;\n\n    // find bottom right point\n    for (var i = 1; i < polygon.length; ++i) {\n        if (v[i][1] < v[br][1] || (v[i][1] === v[br][1] && v[i][0] > v[br][0])) {\n            br = i;\n        }\n    }\n\n    // reverse poly if clockwise\n    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {\n        polygonReverse(polygon);\n        return true;\n    } else {\n        return false;\n    }\n}\n\n/**\n * Reverse the vertices in the polygon\n * @method reverse\n */\nfunction polygonReverse(polygon){\n    var tmp = [];\n    var N = polygon.length;\n    for(var i=0; i!==N; i++){\n        tmp.push(polygon.pop());\n    }\n    for(var i=0; i!==N; i++){\n\t\tpolygon[i] = tmp[i];\n    }\n}\n\n/**\n * Check if a point in the polygon is a reflex point\n * @method isReflex\n * @param  {Number}  i\n * @return {Boolean}\n */\nfunction polygonIsReflex(polygon, i){\n    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));\n}\n\nvar tmpLine1=[],\n    tmpLine2=[];\n\n/**\n * Check if two vertices in the polygon can see each other\n * @method canSee\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */\nfunction polygonCanSee(polygon, a,b) {\n    var p, dist, l1=tmpLine1, l2=tmpLine2;\n\n    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {\n        return false;\n    }\n    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));\n    for (var i = 0; i !== polygon.length; ++i) { // for each edge\n        if ((i + 1) % polygon.length === a || i === a){ // ignore incident edges\n            continue;\n        }\n        if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) { // if diag intersects an edge\n            l1[0] = polygonAt(polygon, a);\n            l1[1] = polygonAt(polygon, b);\n            l2[0] = polygonAt(polygon, i);\n            l2[1] = polygonAt(polygon, i + 1);\n            p = lineInt(l1,l2);\n            if (sqdist(polygonAt(polygon, a), p) < dist) { // if edge is blocking visibility to b\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n/**\n * Check if two vertices in the polygon can see each other\n * @method canSee2\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */\nfunction polygonCanSee2(polygon, a,b) {\n    // for each edge\n    for (var i = 0; i !== polygon.length; ++i) {\n        // ignore incident edges\n        if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b){\n            continue;\n        }\n        if( lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i+1)) ){\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Copy the polygon from vertex i to vertex j.\n * @method copy\n * @param  {Number} i\n * @param  {Number} j\n * @param  {Polygon} [targetPoly]   Optional target polygon to save in.\n * @return {Polygon}                The resulting copy.\n */\nfunction polygonCopy(polygon, i,j,targetPoly){\n    var p = targetPoly || [];\n    polygonClear(p);\n    if (i < j) {\n        // Insert all vertices from i to j\n        for(var k=i; k<=j; k++){\n            p.push(polygon[k]);\n        }\n\n    } else {\n\n        // Insert vertices 0 to j\n        for(var k=0; k<=j; k++){\n            p.push(polygon[k]);\n        }\n\n        // Insert vertices i to end\n        for(var k=i; k<polygon.length; k++){\n            p.push(polygon[k]);\n        }\n    }\n\n    return p;\n}\n\n/**\n * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.\n * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.\n * @method getCutEdges\n * @return {Array}\n */\nfunction polygonGetCutEdges(polygon) {\n    var min=[], tmp1=[], tmp2=[], tmpPoly = [];\n    var nDiags = Number.MAX_VALUE;\n\n    for (var i = 0; i < polygon.length; ++i) {\n        if (polygonIsReflex(polygon, i)) {\n            for (var j = 0; j < polygon.length; ++j) {\n                if (polygonCanSee(polygon, i, j)) {\n                    tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));\n                    tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));\n\n                    for(var k=0; k<tmp2.length; k++){\n                        tmp1.push(tmp2[k]);\n                    }\n\n                    if (tmp1.length < nDiags) {\n                        min = tmp1;\n                        nDiags = tmp1.length;\n                        min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);\n                    }\n                }\n            }\n        }\n    }\n\n    return min;\n}\n\n/**\n * Decomposes the polygon into one or more convex sub-Polygons.\n * @method decomp\n * @return {Array} An array or Polygon objects.\n */\nfunction polygonDecomp(polygon){\n    var edges = polygonGetCutEdges(polygon);\n    if(edges.length > 0){\n        return polygonSlice(polygon, edges);\n    } else {\n        return [polygon];\n    }\n}\n\n/**\n * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.\n * @method slice\n * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()\n * @return {Array}\n */\nfunction polygonSlice(polygon, cutEdges){\n    if(cutEdges.length === 0){\n\t\treturn [polygon];\n    }\n    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length===2 && cutEdges[0][0] instanceof Array){\n\n        var polys = [polygon];\n\n        for(var i=0; i<cutEdges.length; i++){\n            var cutEdge = cutEdges[i];\n            // Cut all polys\n            for(var j=0; j<polys.length; j++){\n                var poly = polys[j];\n                var result = polygonSlice(poly, cutEdge);\n                if(result){\n                    // Found poly! Cut and quit\n                    polys.splice(j,1);\n                    polys.push(result[0],result[1]);\n                    break;\n                }\n            }\n        }\n\n        return polys;\n    } else {\n\n        // Was given one edge\n        var cutEdge = cutEdges;\n        var i = polygon.indexOf(cutEdge[0]);\n        var j = polygon.indexOf(cutEdge[1]);\n\n        if(i !== -1 && j !== -1){\n            return [polygonCopy(polygon, i,j),\n                    polygonCopy(polygon, j,i)];\n        } else {\n            return false;\n        }\n    }\n}\n\n/**\n * Checks that the line segments of this polygon do not intersect each other.\n * @method isSimple\n * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]\n * @return {Boolean}\n * @todo Should it check all segments with all others?\n */\nfunction polygonIsSimple(polygon){\n    var path = polygon, i;\n    // Check\n    for(i=0; i<path.length-1; i++){\n        for(var j=0; j<i-1; j++){\n            if(lineSegmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){\n                return false;\n            }\n        }\n    }\n\n    // Check the segment between the last and the first point to all others\n    for(i=1; i<path.length-2; i++){\n        if(lineSegmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction getIntersectionPoint(p1, p2, q1, q2, delta){\n\tdelta = delta || 0;\n\tvar a1 = p2[1] - p1[1];\n\tvar b1 = p1[0] - p2[0];\n\tvar c1 = (a1 * p1[0]) + (b1 * p1[1]);\n\tvar a2 = q2[1] - q1[1];\n\tvar b2 = q1[0] - q2[0];\n\tvar c2 = (a2 * q1[0]) + (b2 * q1[1]);\n\tvar det = (a1 * b2) - (a2 * b1);\n\n\tif(!scalar_eq(det,0,delta)){\n\t\treturn [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det];\n\t} else {\n\t\treturn [0,0];\n    }\n}\n\n/**\n * Quickly decompose the Polygon into convex sub-polygons.\n * @method quickDecomp\n * @param  {Array} result\n * @param  {Array} [reflexVertices]\n * @param  {Array} [steinerPoints]\n * @param  {Number} [delta]\n * @param  {Number} [maxlevel]\n * @param  {Number} [level]\n * @return {Array}\n */\nfunction polygonQuickDecomp(polygon, result,reflexVertices,steinerPoints,delta,maxlevel,level){\n    maxlevel = maxlevel || 100;\n    level = level || 0;\n    delta = delta || 25;\n    result = typeof(result)!==\"undefined\" ? result : [];\n    reflexVertices = reflexVertices || [];\n    steinerPoints = steinerPoints || [];\n\n    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points\n    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars\n    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers\n    var lowerPoly=[], upperPoly=[]; // polygons\n    var poly = polygon,\n        v = polygon;\n\n    if(v.length < 3){\n\t\treturn result;\n    }\n\n    level++;\n    if(level > maxlevel){\n        console.warn(\"quickDecomp: max level (\"+maxlevel+\") reached.\");\n        return result;\n    }\n\n    for (var i = 0; i < polygon.length; ++i) {\n        if (polygonIsReflex(poly, i)) {\n            reflexVertices.push(poly[i]);\n            upperDist = lowerDist = Number.MAX_VALUE;\n\n\n            for (var j = 0; j < polygon.length; ++j) {\n                if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) { // if line intersects with an edge\n                    p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection\n                    if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) { // make sure it's inside the poly\n                        d = sqdist(poly[i], p);\n                        if (d < lowerDist) { // keep only the closest intersection\n                            lowerDist = d;\n                            lowerInt = p;\n                            lowerIndex = j;\n                        }\n                    }\n                }\n                if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n                    p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));\n                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {\n                        d = sqdist(poly[i], p);\n                        if (d < upperDist) {\n                            upperDist = d;\n                            upperInt = p;\n                            upperIndex = j;\n                        }\n                    }\n                }\n            }\n\n            // if there are no vertices to connect to, choose a point in the middle\n            if (lowerIndex === (upperIndex + 1) % polygon.length) {\n                //console.log(\"Case 1: Vertex(\"+i+\"), lowerIndex(\"+lowerIndex+\"), upperIndex(\"+upperIndex+\"), poly.size(\"+polygon.length+\")\");\n                p[0] = (lowerInt[0] + upperInt[0]) / 2;\n                p[1] = (lowerInt[1] + upperInt[1]) / 2;\n                steinerPoints.push(p);\n\n                if (i < upperIndex) {\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);\n                    polygonAppend(lowerPoly, poly, i, upperIndex+1);\n                    lowerPoly.push(p);\n                    upperPoly.push(p);\n                    if (lowerIndex !== 0){\n                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());\n                        polygonAppend(upperPoly, poly,lowerIndex,poly.length);\n                    }\n                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);\n                    polygonAppend(upperPoly, poly,0,i+1);\n                } else {\n                    if (i !== 0){\n                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());\n                        polygonAppend(lowerPoly, poly,i,poly.length);\n                    }\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);\n                    polygonAppend(lowerPoly, poly,0,upperIndex+1);\n                    lowerPoly.push(p);\n                    upperPoly.push(p);\n                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);\n                    polygonAppend(upperPoly, poly,lowerIndex,i+1);\n                }\n            } else {\n                // connect to the closest point within the triangle\n                //console.log(\"Case 2: Vertex(\"+i+\"), closestIndex(\"+closestIndex+\"), poly.size(\"+polygon.length+\")\\n\");\n\n                if (lowerIndex > upperIndex) {\n                    upperIndex += polygon.length;\n                }\n                closestDist = Number.MAX_VALUE;\n\n                if(upperIndex < lowerIndex){\n                    return result;\n                }\n\n                for (var j = lowerIndex; j <= upperIndex; ++j) {\n                    if (\n                        isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) &&\n                        isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))\n                    ) {\n                        d = sqdist(polygonAt(poly, i), polygonAt(poly, j));\n                        if (d < closestDist && polygonCanSee2(poly, i, j)) {\n                            closestDist = d;\n                            closestIndex = j % polygon.length;\n                        }\n                    }\n                }\n\n                if (i < closestIndex) {\n                    polygonAppend(lowerPoly, poly,i,closestIndex+1);\n                    if (closestIndex !== 0){\n                        polygonAppend(upperPoly, poly,closestIndex,v.length);\n                    }\n                    polygonAppend(upperPoly, poly,0,i+1);\n                } else {\n                    if (i !== 0){\n                        polygonAppend(lowerPoly, poly,i,v.length);\n                    }\n                    polygonAppend(lowerPoly, poly,0,closestIndex+1);\n                    polygonAppend(upperPoly, poly,closestIndex,i+1);\n                }\n            }\n\n            // solve smallest poly first\n            if (lowerPoly.length < upperPoly.length) {\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            } else {\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            }\n\n            return result;\n        }\n    }\n    result.push(polygon);\n\n    return result;\n}\n\n/**\n * Remove collinear points in the polygon.\n * @method removeCollinearPoints\n * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.\n * @return {Number}           The number of points removed\n */\nfunction polygonRemoveCollinearPoints(polygon, precision){\n    var num = 0;\n    for(var i=polygon.length-1; polygon.length>3 && i>=0; --i){\n        if(collinear(polygonAt(polygon, i-1),polygonAt(polygon, i),polygonAt(polygon, i+1),precision)){\n            // Remove the middle point\n            polygon.splice(i%polygon.length,1);\n            num++;\n        }\n    }\n    return num;\n}\n\n/**\n * Remove duplicate points in the polygon.\n * @method removeDuplicatePoints\n * @param  {Number} [precision] The threshold to use when determining whether two points are the same. Use zero for best precision.\n */\nfunction polygonRemoveDuplicatePoints(polygon, precision){\n    for(var i=polygon.length-1; i>=1; --i){\n        var pi = polygon[i];\n        for(var j=i-1; j>=0; --j){\n            if(points_eq(pi, polygon[j], precision)){\n                polygon.splice(i,1);\n                continue;\n            }\n        }\n    }\n}\n\n/**\n * Check if two scalars are equal\n * @static\n * @method eq\n * @param  {Number} a\n * @param  {Number} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */\nfunction scalar_eq(a,b,precision){\n    precision = precision || 0;\n    return Math.abs(a-b) <= precision;\n}\n\n/**\n * Check if two points are equal\n * @static\n * @method points_eq\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */\nfunction points_eq(a,b,precision){\n    return scalar_eq(a[0],b[0],precision) && scalar_eq(a[1],b[1],precision);\n}\n\n},{}]},{},[1])\n(1)\n});"],"names":["e","exports","module","define","amd","f","window","global","self","decomp","t","n","r","s","o","u","a","require","undefined","i","Error","call","length","_dereq_","module1","exports1","lineSegmentsIntersect","p1","p2","q1","q2","dx","dy","da","db","triangleArea","b","c","isRightOn","polygon","edges","polygonGetCutEdges","min","tmp1","tmp2","tmpPoly","nDiags","Number","MAX_VALUE","polygonIsReflex","j","polygonCanSee","polygonAt","dist","sqdist","p","l1","l2","lineInt","precision","a1","b1","c1","a2","b2","c2","det","scalar_eq","tmpLine1","tmpLine2","polygonCopy","k","push","polygonSlice","cutEdges","Array","polys","cutEdge","result","splice","indexOf","quickDecomp","polygonQuickDecomp","reflexVertices","steinerPoints","delta","maxlevel","level","upperInt","lowerInt","upperDist","lowerDist","d","closestDist","upperIndex","lowerIndex","closestIndex","lowerPoly","upperPoly","v","console","warn","poly","isLeft","getIntersectionPoint","polygonAppend","isLeftOn","polygonCanSee2","isSimple","path","removeCollinearPoints","num","ab","tmpPoint1","bc","tmpPoint2","angle","Math","acos","dot","magA","sqrt","removeDuplicatePoints","pi","makeCCW","br","polygonReverse","tmp","N","pop","from","to","targetPoly","abs"],"version":3,"file":"index.75306185.js.map"}